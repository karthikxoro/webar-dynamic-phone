<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Surface Tracking</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 3;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
        }
        
        #fileInput {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 3;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
        }
        
        .tap-indicator {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
            animation: tapRipple 0.6s ease-out;
        }
        
        @keyframes tapRipple {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
        
        <div id="ui">
            <div>AR Surface Tracking</div>
            <div id="status">Initializing camera...</div>
            <div style="margin-top: 10px; font-size: 12px;">
                • Upload a 3D model below<br>
                • Tap screen to place model<br>
                • Model stays anchored to surface
            </div>
        </div>
        
        <input type="file" id="fileInput" accept=".obj,.gltf,.glb" title="Upload 3D Model">
    </div>

    <script>
        class ARSurfaceTracker {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.status = document.getElementById('status');
                this.fileInput = document.getElementById('fileInput');
                
                // Three.js setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas, 
                    alpha: true,
                    antialias: true 
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // AR tracking variables
                this.isTracking = false;
                this.placedModels = [];
                this.currentModel = null;
                this.surfacePoints = [];
                this.floorLevel = 0;
                
                // Camera calibration (estimated values for mobile)
                this.cameraMatrix = {
                    fx: 800, fy: 800,
                    cx: 320, cy: 240
                };
                
                this.init();
            }
            
            async init() {
                try {
                    await this.setupCamera();
                    this.setupLighting();
                    this.createDefaultModel();
                    this.setupEventListeners();
                    this.startTracking();
                    this.status.textContent = 'Ready - Tap to place model';
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.status.textContent = 'Error: ' + error.message;
                }
            }
            
            async setupCamera() {
                const constraints = {
                    video: {
                        facingMode: { exact: 'environment' },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = stream;
                    
                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            resolve();
                        };
                    });
                } catch (error) {
                    // Fallback to any available camera
                    const fallbackStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    this.video.srcObject = fallbackStream;
                    
                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            resolve();
                        };
                    });
                }
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (sun simulation)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Point light for better illumination
                const pointLight = new THREE.PointLight(0xffffff, 0.4, 100);
                pointLight.position.set(0, 5, 0);
                this.scene.add(pointLight);
            }
            
            createDefaultModel() {
                // Create a default 3D model (a colorful cube with some detail)
                const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const materials = [
                    new THREE.MeshLambertMaterial({ color: 0xff0000 }), // Right
                    new THREE.MeshLambertMaterial({ color: 0x00ff00 }), // Left
                    new THREE.MeshLambertMaterial({ color: 0x0000ff }), // Top
                    new THREE.MeshLambertMaterial({ color: 0xffff00 }), // Bottom
                    new THREE.MeshLambertMaterial({ color: 0xff00ff }), // Front
                    new THREE.MeshLambertMaterial({ color: 0x00ffff })  // Back
                ];
                
                this.currentModel = new THREE.Mesh(geometry, materials);
                this.currentModel.castShadow = true;
                this.currentModel.receiveShadow = true;
                
                // Add some animation
                this.currentModel.userData = {
                    originalY: 0,
                    time: 0,
                    placed: false
                };
            }
            
            setupEventListeners() {
                // Handle screen taps
                this.canvas.addEventListener('click', (e) => this.handleTap(e));
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleTap(e.touches[0]);
                });
                
                // Handle window resize
                window.addEventListener('resize', () => this.handleResize());
                
                // Handle file upload
                this.fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
                
                // Prevent default touch behaviors
                document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            }
            
            handleTap(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Show tap indicator
                this.showTapIndicator(x, y);
                
                // Simulate surface detection at tap point
                const surfacePoint = this.detectSurface(x, y);
                if (surfacePoint && this.currentModel) {
                    this.placeModel(surfacePoint);
                }
            }
            
            showTapIndicator(x, y) {
                const indicator = document.createElement('div');
                indicator.className = 'tap-indicator';
                indicator.style.left = (x - 30) + 'px';
                indicator.style.top = (y - 30) + 'px';
                document.body.appendChild(indicator);
                
                setTimeout(() => {
                    document.body.removeChild(indicator);
                }, 600);
            }
            
            detectSurface(screenX, screenY) {
                // Simulate surface detection using simple heuristics
                // In a real AR system, this would use computer vision algorithms
                
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // Calculate distance from center (simulating depth)
                const distanceFromCenter = Math.sqrt(
                    Math.pow(screenX - centerX, 2) + Math.pow(screenY - centerY, 2)
                );
                
                // Simulate depth based on screen position
                const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
                const normalizedDistance = distanceFromCenter / maxDistance;
                const depth = 2 + normalizedDistance * 3; // 2-5 units away
                
                // Convert screen coordinates to world coordinates
                const worldX = (screenX - centerX) * depth * 0.002;
                const worldZ = -depth;
                const worldY = this.floorLevel; // Place on detected floor
                
                return new THREE.Vector3(worldX, worldY, worldZ);
            }
            
            placeModel(position) {
                if (!this.currentModel) return;
                
                // Clone the current model for placement
                const placedModel = this.currentModel.clone();
                placedModel.position.copy(position);
                placedModel.userData = {
                    originalY: position.y,
                    time: 0,
                    placed: true,
                    id: Date.now()
                };
                
                // Add slight random rotation for variety
                placedModel.rotation.y = Math.random() * Math.PI * 2;
                
                this.scene.add(placedModel);
                this.placedModels.push(placedModel);
                
                this.status.textContent = `Placed model ${this.placedModels.length} - Tap again to place more`;
                
                // Limit number of placed models to prevent performance issues
                if (this.placedModels.length > 10) {
                    const oldModel = this.placedModels.shift();
                    this.scene.remove(oldModel);
                }
            }
            
            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                this.status.textContent = 'Loading 3D model...';
                
                try {
                    // For this demo, we'll create a more complex default model
                    // In a real implementation, you'd use a proper 3D model loader
                    this.createCustomModel(file.name);
                    this.status.textContent = `Loaded ${file.name} - Tap to place`;
                } catch (error) {
                    console.error('Model loading error:', error);
                    this.status.textContent = 'Error loading model';
                }
            }
            
            createCustomModel(fileName) {
                // Create a more complex model based on file name
                const group = new THREE.Group();
                
                // Base
                const baseGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.1, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -0.2;
                group.add(base);
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Top
                const topGeometry = new THREE.SphereGeometry(0.2, 8, 6);
                const topMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6347 });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = 0.4;
                group.add(top);
                
                group.castShadow = true;
                group.receiveShadow = true;
                
                // Remove old model
                if (this.currentModel) {
                    this.scene.remove(this.currentModel);
                }
                
                this.currentModel = group;
                this.currentModel.userData = {
                    originalY: 0,
                    time: 0,
                    placed: false
                };
            }
            
            startTracking() {
                this.isTracking = true;
                this.animate();
            }
            
            animate() {
                if (!this.isTracking) return;
                
                requestAnimationFrame(() => this.animate());
                
                // Animate placed models
                this.placedModels.forEach(model => {
                    if (model.userData.placed) {
                        model.userData.time += 0.016; // ~60fps
                        
                        // Subtle floating animation
                        const floatOffset = Math.sin(model.userData.time * 2) * 0.02;
                        model.position.y = model.userData.originalY + floatOffset;
                        
                        // Gentle rotation
                        model.rotation.y += 0.005;
                    }
                });
                
                // Update camera (simulate AR tracking)
                this.updateARCamera();
                
                // Render the scene
                this.renderer.render(this.scene, this.camera);
            }
            
            updateARCamera() {
                // Simulate slight camera movement/stabilization
                // In a real AR system, this would be updated by tracking algorithms
                
                const time = Date.now() * 0.001;
                
                // Subtle camera shake simulation
                this.camera.position.x = Math.sin(time * 0.5) * 0.01;
                this.camera.position.y = Math.cos(time * 0.3) * 0.01;
                this.camera.position.z = 0;
                
                this.camera.lookAt(0, 0, -3);
            }
            
            handleResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
        }
        
        // Initialize AR tracking when page loads
        window.addEventListener('load', () => {
            new ARSurfaceTracker();
        });
        
        // Handle device orientation changes
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                window.location.reload();
            }, 500);
        });
    </script>
</body>
</html>